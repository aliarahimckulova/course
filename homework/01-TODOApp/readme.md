# Домашнее задание #1. Приложение со списком дел

![то, что должно получиться][todoapp]

__В первую очередь пройдите 1, 2, 3, 4 и 6 разделы [этого
HTMLAcademy курса][htmlacademy].__

Привет. Настало время для первого домашнего задания.\
Оно может показаться объёмным и даже пугающим, но не стоит бояться
и падать в обморок; я пишу эти справочные материалы как раз для
того, чтобы помочь вам справиться с заданием лучше.

Итак, поехали. В этот раз мы делаем "приложение", где можно вести
учёт своих дел, которые необходимо сделать. User Experience
нашей с вами версии этого приложения безумно прост: пользователь
вводит текст напоминалки в поле, нажимает Enter на клавиатуре,
напоминашка добавляется в список. (Пока что) Тудушки нельзя ни
удалять, ни редактировать. Более того, они никуда не сохраняются
&mdash; если обновить страницу, то земля пухом всему контенту,
который добавил пользователь.

Что же, приступим. Как всегда, сначала я приведу все измерения,
шрифты и прочипе характеристики макета. После этого я дам пару
комментариев насчёт JS-составляющей приложения, а в самом конце
приведу HTML-заготовку с подключёнными шрифтами (_о Боже, в этот раз
это не PT Sans_).

А нет, всё же, перед тем, как приступить, в качестве финального
слова я хочу ещё раз сделать акцент на том, что не стоит переживать,
если это домашнее задание сходу решить не получится или вы
застрянете на какой-нибудь детали. Это домашнее задание будет
разобрано на паре для всех. Мы поговорим обо всех возможных
проблемах, с которыми вам могло прийтись столкнуться и обо всех
шагах решения этой задачи.

## Данные макета

С самого начала хочу заметить, что, как можно увидеть на скрине,
на страничке есть текстовое поле. Давайте сначала поговорим о том,
как его создать в HTML.

```html
<input />
```

Просто, правда? О, но подождите, на скриншоте есть ещё и
текст-placeholder, который автоматически пропадает, когда
пользователь начнёт что-то вводить в текстовое поле. Как это
сделать?

```html
<input placeholder='Tell future self what needs to be done' />
```

Отлично. С HTML-точки зрения всё необходимое о такой новой
сущности, как текстовое поле, мы, вроде как, всё узнали.

Теперь давайте поговорим об текстовом поле конкретно в этой
вёрстке.\
В принципе, невооружённым глазом видно, что оно `К Р А С И В О Е`.
Так вот, дело в том, что за внешней привлекательностью кроется
некоторая деталь в реализации. Это текстовое поле обёрнуто в `div`.

Примерно так:

```html
<div class='input-container'>
    <input class='input' />
</div>
```

Зачем, спросите вы? Хороший вопрос. Сейчас я поспешу на него
ответить.\
Дело в том, что закруглённая светло-серая рамка и тень наложены
_не на само текстовое поле_, а на `div`-контейнер этого текстового
поля. У самого же инпута сброшены все стили.

Давайте посмотрим на примере, как мы к этому пришли.\
Обычное текстовое поле выглядит _примерно_ так:

![стили юзер-агента][user-agent-input]

Когда мы щёлкаем внутри него мышкой (делаем его активным), вокруг
него появляется такая богопротивная рамка:

![стили юзер-агента под фокусом][user-agent-input-focus]

Фу. Мы хотим, чтобы было `K R A S I V O`, а не вот это дефолтное
убожество.

Давайте сбросим стили этого ужасного текстового поля.

```css
input {
    border: none; /* убираем серую рамку */
}

input:focus {
    outline: none; /* убираем синюю рамку в активном состоянии */
}
```

Как это выглядит?

![инпут со сброшенными стилями][styles-reset-input]

Уф. В этом коде есть кусочек синтаксиса, который мы ещё не знаем.
Что такое `:hover`? На что это влияет?

В общем и целом пока не нужно понимать полный механизм работы этого.
Этот кусочек синтаксиса называется _псевдо-классы_. По-большей
части, псевдо-классы модифицируют селекторы, указывая браузеру,
что все свойства, описанные в этом "модифицированном" селекторе
следует применять только тогда, когда элемент находится в
определённом состоянии. Например, на элементе сейчас находится
фокус пользовательского ввода, что и является нашим случам и за что
и отвечает псевдо-класс `:hover`.

Теперь мы наконец-то можем обернуть `input` в `div` и радоваться
жизни. Все стили вроде отступов внутри, рамки, закругления и теньки
_гораздо_ проще применять на контейнер. Поверьте мне. Более того,
это гораздо более гибкий поход. Если мы, например, захотим добавить
кнопку ввода эмоджи, её будет гораздо проще поместить внутрь
контейнера, рядом с настоящим текстовым полем. Посмотрите, как это
сделано в Twitch:

![подход твича][twitch-input]

Ещё пара деталей. Я, _разумеется_, об этом не говорил, но CSS
называется CSS (_Cascade_ Style Sheets), потому что стили
"каскадируют" по дереву вашего документа. То есть, стили,
применённые на элементародителя, будут применены и на
элемента-ребёнка. Это важно. Конечно, ребёнок может иметь
специфичные для себя стили, в таком случае, они перезаписываются
(override), по сути.

Только вот в чём подвох: с инпутами не всё так просто. Стили
пользовательского агента (User Agent Styles, т.е. стили,
заданные самим браузером) в них заданы даже для шрифтов.
Нельзя так просто взять и сделать

```css
body {
    font-family: 'Roboto', sans-serif;
}
```

и надеяться, что в текстовом поле будет тоже установлен шрифт
Roboto (потому что этого не произойдёт). То же самое и с цветом
фона. Будьте аккуратны с этим: задавайте все стили для инпута в
селекторе для этого инпута.

Но постойте. Мы поместили инпут в контейнер-`div`. Контейнер
растянут на ширину всего родительского элемента, а само поле не
растянуто на ширину всего контейнера! Как так, что делать? Ответ
прост:

```css
.input {
    width: 100%;
}
```

Задавая ширине значение 100%, мы вежливо просим наше текстовое
поле растянуться на всю ширину родительского элемента. Это работает
для всего, не только для текстовых полей.

Последняя деталь. Помните, что мы задавали текст так называемому
placeholder-у текстового поля? Обратите внимание, что даже
в стандартных стилях браузера у него другой цвет шрифта. Как бы нам
тоже изменить этот цвет шрифта?

Время совсем чуть-чуть коснуться ещё одной доселе неизвестной нам
фишки CSS, которая называется `псевдо-элементы`. Псевдо-элементы
по большей части позволяют нам применять свойства к элементам,
которых нет в DOM-дереве, которое можно явно получить из нашего
HTML-кода, но они для браузера они там фактически присутствуют.
Например, тот самый пресловутый placeholder. Итак, как ему задать
цвет текста? Очень просто:

```css
.input::placeholder {
    color: <color>;
}
```

Обратите внимание, что псевдо-классы обозначаются через одно
двоеточие, а псевдо-элементы через два. (сравните: `:focus` vs.
`::placeholder`).

Ладно, достаточно предисловий. Всё приложение расположено в одном
`div`-е, поэтому начнём мы с его измерений.

- Ширина блока приложения: `650px`
- `margin: 30px auto`. Это задаёт одновременно и отступ в 30
  пикселей сверху, так и центрирует элемент (так как у него
  фиксированная ширина)
- Отступы внутри: `50px` сверху, `30px` по бокам и снизу
- Цвет фона: `rgb(247, 247, 247)`
- Радиус закругления: `2px`
- Тень: `0px 0px 30px rgba(0, 0, 0, .1)`. Если не понимаете, что
  значат эти цифры, смотрите ридми к первой практике.
- Шрифты всего приложения, кроме заголовка: `Roboto`, 
  `font-weight: 300`. Значение веса 300 делает шрифт тонким.

Заголовок приложения (STUFF TO DO):
- Шрифт: `Josefin Sans`, вес `700`, размер `52px`, цвет
  `rgb(65, 65, 65)`
- Выравнивание текста по центру
- Тень от текста (все эти цифры работают так же, как и тень
  элемента `box-shadow`): `text-shadow: 2px 2px 0px 
  rgba(0, 0, 0, .15)`
- Отступ от других элементов приложения (снизу): `50px`
  
Инпут (сам инпут):
- Шрифт `Roboto`, вес `300`, размер `27px`
- Отступы внутри: `2px`
- Цвет фона: `rgb(248, 248, 248)`
- Цвет шрифта в placeholder-е: `rgb(150, 150, 150)`

Инпут (обёртка):
- Отступы внутри: сверху и снизу `9px`, по бокам `14px`
- Рамка: `border: 1px rgb(230, 230, 230) solid` (йей, ещё одно
  CSS-свойство! первая чиселка задаёт толщину рамки, вторая &mdash;
  цвет, третья &mdash; стиль рамки (в данном случае это сплошная
  линия)
- Закругление: `4px`
- Тень: `0px 0px 30px rgba(0, 0, 0, .05)`
- Цвет фона: такой же, как и инпута
- Отступ от списка тудушек: `30px`

Контейнер с тудушками:
- Тень: `0px 0px 40px rgba(0, 0, 0, .05)`

Элемент тудушки:
- Шрифт: `27px`, цвет `rgb(65, 65, 65)`
- Отступы внутри: сверху и снизу`9px`, по бокам `14px`
- Цвет фона: `rgb(247, 247, 247)`
- Рамка здесь задаётся не через shorthand-свойство, а через
  отдельные свойства.

  ```css
  border-width: 1px;
  border-color: rgb(240, 240, 240);
  border-style: solid none none none;
  ```

  Почему так? Потому что мы хотим сделать рамку сплошной линией
  только сверху каждой тудушки, а по остальным сторонам её не должно
  быть (отсюда `none`).

Итак. Как вы уже могли понять, за тудушки отвечает два элемента:
их контейнер и сам элемент тудушки, который добавляется _в_
контейнер. Давайте посмотрим, как это выглядит с точки зрения
вёрстки:
 
```html
<div class='todos'>
    <div class='todo'>Finish my frontend homework</div>
    <div class='todo'>Do something</div>
</div>
```

Новые TODOs мы будем добавлять в контейнер с помощью JavaScript.
Это плавно приводит меня к следующему пункту моего повествования.

## Необходимые JavaScript-сведения

Забудем пока про TODO-шки. Давайте лучше поговорим о том, что
нигде нет кнопки, которая добавляла бы новые напоминания, а
это происходит по нажатию клавиши Enter. Как это сделать?

Вы, должно быть, помните про обработчики событий с прошлого
занятия. Разумеется, на нажатия кнопки на клавиатуре тоже
есть свои событияф. Аж три: `keypress, keydown, keyup`.
Нас сейчас интересует именно `keyup`. Оно срабатывает, когда
пользователь отпускает кнопку клавиатуры. Давайте посмотрим, как
его регистрировать.

```javascript
// Предположим, инпуту присвоен id 'input'. Получим этот элемент
// для дальнейшего его использования в коде.

const $input = document.querySelector('#input')

// Теперь прикрепим обработчик события 'keyup' на этот элемент.

$input.addEventListener('keyup', function(event) {
    // обратите внимание, что в этот раз функция-обработчик
    // не от нуля аргументов, а от одного аргумента 'event'.
    // При срабатывании события в event будет передан объект,
    // содержащий информацию о произошедшем событии.
    // В частности, у этого объекта нас интересует поле
    // code, содержащее описанное строкой имя клавиши, которая
    // была нажата.
    if (event.code === 'Enter') {
        // Проверяем, что нажат был именно Enter. Если это так,
        // делаем то, что нам нужно. Иначе просто выходим из
        // условия if и ничего не делаем в обработчике событий.
    }
})
```

Постарайтесь разобраться в этом кусочке кода.

Теперь давайте поговорим о том, как программно (с помощью JS, то
есть) добавлять новые элементы к существующему DOM-дереву.

Давайте снова вернёмся к примерной структуре вашего контейнера
тудушек. Мы хотим добавить к списку напоминаний новое. Программно.

```html
<div class='todos' id='todos-container'>
    <div class='todo'>Finish my frontend homework</div>
    <div class='todo'>Do something</div>
</div>
```

```javascript
// Получим элемент контейнера TODO-шек для дальнейшей работы с ним

const $todos = document.querySelector('#todos-container')

// Создадим новый элемент тега div.
// Этим занимается метод document.createElement(tag).
// <div></div>

const todo = document.createElement('div')

// Добавим к этому элементу класс todo.
// Это эквивалентно добавлению html-атрибута class.
// <div class='todo'></div>
// У каждого элемента есть свойство classList, к которому можно
// добавлять классы с помощью метода add.

todo.classList.add('todo')

// Изменим текстовое содержимое тега на 'Do stuff'
// Это почти эквивалентно изменению содержимого тега.
// <div class='todo'>Do stuff</div>

todo.textContent = 'Do stuff'

// Отлично. Элемент создан в памяти. Однако, как вы, наверное,
// могли понять, он не прикреплён фактически ни к какому месту в
// уже существующем DOM-дереве. Поэтому если выполнить сейчас весь
// этот код до этого места в консоли, новый элемент не будет
// отображаться на странице.
// Для того, чтобы куда-то прикрепить элемент, мы должны взять
// элемент-родитель (в нашем случае это div#todos-container, в коде
// объявленный как $todos) и вызвать у него метод 
// appendChild(child).

$todos.appendChild(todo)

// Ура! На этом этапе элемент отображается на странице, так как был
// прикреплён к DOM-дереву как дочерний элемент контейнера
// напоминаний.
```

## HTML-заготовка

```html
<!doctype html>
<html>
  <head>
    <title>Заголовок страницы</title>

    <!-- строка ниже подключает шрифты Josefin Sans и Roboto -->
    <link href="https://fonts.googleapis.com/css?family=Josefin+Sans:700|Roboto:300" rel="stylesheet">
  </head>

  <body>

  </body>
</html>
```

Удачи! Она вам понадобится.\
И спасибо, что дочитали эту справку до конца.\
На её написание ушёл не один час.

## Ссылки для дальнейшего прочтения
- [Псевдо-классы][pseudoclasses]
- [Псевдо-элементы][pseudoelements]
- [Свойство text-shadow][text-shadow]
- [Свойство box-shadow][box-shadow]
- [Свойство border][border]
- [Событие keyup][keyup]
- [createElement API][createElement]
- [classList API][classList]
- [appendChild API][appendChild]

[todoapp]: ./todos.png

[htmlacademy]: https://htmlacademy.ru/courses/4

[user-agent-input]: ./default-input.png
[user-agent-input-focus]: ./default-input-focus.png
[styles-reset-input]: ./styles-reset-input.png
[twitch-input]: ./twitch.png

[pseudoclasses]: https://developer.mozilla.org/ru/docs/Web/CSS/%D0%9F%D1%81%D0%B5%D0%B2%D0%B4%D0%BE-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B
[pseudoelements]: https://developer.mozilla.org/ru/docs/Web/CSS/Pseudo-elements
[text-shadow]: https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow
[box-shadow]: https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow
[border]: https://developer.mozilla.org/en-US/docs/Web/CSS/border
[keyup]: https://developer.mozilla.org/en-US/docs/Web/Events/keyup
[createElement]: https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
[classList]: https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
[appendChild]: https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild